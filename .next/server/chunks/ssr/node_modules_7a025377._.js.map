{"version":3,"sources":["turbopack:///[project]/node_modules/next/src/server/app-render/encryption-utils.ts","turbopack:///[project]/node_modules/next/src/server/app-render/encryption.ts","turbopack:///[project]/node_modules/@clerk/nextjs/src/server/keyless-custom-headers.ts","turbopack:///[project]/node_modules/@clerk/nextjs/dist/esm/server/keyless.js","turbopack:///[project]/node_modules/@clerk/nextjs/dist/esm/app-router/keyless-actions.js"],"sourcesContent":["import type { ActionManifest } from '../../build/webpack/plugins/flight-client-entry-plugin'\nimport type {\n  ClientReferenceManifest,\n  ClientReferenceManifestForRsc,\n} from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { workAsyncStorage } from './work-async-storage.external'\n\nlet __next_loaded_action_key: CryptoKey\n\nexport function arrayBufferToString(\n  buffer: ArrayBuffer | Uint8Array<ArrayBufferLike>\n) {\n  const bytes = new Uint8Array(buffer)\n  const len = bytes.byteLength\n\n  // @anonrig: V8 has a limit of 65535 arguments in a function.\n  // For len < 65535, this is faster.\n  // https://github.com/vercel/next.js/pull/56377#pullrequestreview-1656181623\n  if (len < 65535) {\n    return String.fromCharCode.apply(null, bytes as unknown as number[])\n  }\n\n  let binary = ''\n  for (let i = 0; i < len; i++) {\n    binary += String.fromCharCode(bytes[i])\n  }\n  return binary\n}\n\nexport function stringToUint8Array(binary: string) {\n  const len = binary.length\n  const arr = new Uint8Array(len)\n\n  for (let i = 0; i < len; i++) {\n    arr[i] = binary.charCodeAt(i)\n  }\n\n  return arr\n}\n\nexport function encrypt(key: CryptoKey, iv: Uint8Array, data: Uint8Array) {\n  return crypto.subtle.encrypt(\n    {\n      name: 'AES-GCM',\n      iv,\n    },\n    key,\n    data\n  )\n}\n\nexport function decrypt(key: CryptoKey, iv: Uint8Array, data: Uint8Array) {\n  return crypto.subtle.decrypt(\n    {\n      name: 'AES-GCM',\n      iv,\n    },\n    key,\n    data\n  )\n}\n\n// This is a global singleton that is used to encode/decode the action bound args from\n// the closure. This can't be using a AsyncLocalStorage as it might happen on the module\n// level. Since the client reference manifest won't be mutated, let's use a global singleton\n// to keep it.\nconst SERVER_ACTION_MANIFESTS_SINGLETON = Symbol.for(\n  'next.server.action-manifests'\n)\n\nexport function setReferenceManifestsSingleton({\n  page,\n  clientReferenceManifest,\n  serverActionsManifest,\n  serverModuleMap,\n}: {\n  page: string\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n  serverActionsManifest: DeepReadonly<ActionManifest>\n  serverModuleMap: {\n    [id: string]: {\n      id: string\n      chunks: string[]\n      name: string\n    }\n  }\n}) {\n  // @ts-expect-error\n  const clientReferenceManifestsPerPage = globalThis[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ]?.clientReferenceManifestsPerPage as\n    | undefined\n    | DeepReadonly<Record<string, ClientReferenceManifest>>\n\n  // @ts-expect-error\n  globalThis[SERVER_ACTION_MANIFESTS_SINGLETON] = {\n    clientReferenceManifestsPerPage: {\n      ...clientReferenceManifestsPerPage,\n      [normalizeAppPath(page)]: clientReferenceManifest,\n    },\n    serverActionsManifest,\n    serverModuleMap,\n  }\n}\n\nexport function getServerModuleMap() {\n  const serverActionsManifestSingleton = (globalThis as any)[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ] as {\n    serverModuleMap: {\n      [id: string]: {\n        id: string\n        chunks: string[]\n        name: string\n      }\n    }\n  }\n\n  if (!serverActionsManifestSingleton) {\n    throw new InvariantError('Missing manifest for Server Actions.')\n  }\n\n  return serverActionsManifestSingleton.serverModuleMap\n}\n\nexport function getClientReferenceManifestForRsc(): DeepReadonly<ClientReferenceManifestForRsc> {\n  const serverActionsManifestSingleton = (globalThis as any)[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ] as {\n    clientReferenceManifestsPerPage: DeepReadonly<\n      Record<string, ClientReferenceManifest>\n    >\n  }\n\n  if (!serverActionsManifestSingleton) {\n    throw new InvariantError('Missing manifest for Server Actions.')\n  }\n\n  const { clientReferenceManifestsPerPage } = serverActionsManifestSingleton\n  const workStore = workAsyncStorage.getStore()\n\n  if (!workStore) {\n    // If there's no work store defined, we can assume that a client reference\n    // manifest is needed during module evaluation, e.g. to create a server\n    // action using a higher-order function. This might also use client\n    // components which need to be serialized by Flight, and therefore client\n    // references need to be resolvable. To make this work, we're returning a\n    // merged manifest across all pages. This is fine as long as the module IDs\n    // are not page specific, which they are not for Webpack. TODO: Fix this in\n    // Turbopack.\n    return mergeClientReferenceManifests(clientReferenceManifestsPerPage)\n  }\n\n  const clientReferenceManifest =\n    clientReferenceManifestsPerPage[workStore.route]\n\n  if (!clientReferenceManifest) {\n    throw new InvariantError(\n      `Missing Client Reference Manifest for ${workStore.route}.`\n    )\n  }\n\n  return clientReferenceManifest\n}\n\nexport async function getActionEncryptionKey() {\n  if (__next_loaded_action_key) {\n    return __next_loaded_action_key\n  }\n\n  const serverActionsManifestSingleton = (globalThis as any)[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ] as {\n    serverActionsManifest: DeepReadonly<ActionManifest>\n  }\n\n  if (!serverActionsManifestSingleton) {\n    throw new InvariantError('Missing manifest for Server Actions.')\n  }\n\n  const rawKey =\n    process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY ||\n    serverActionsManifestSingleton.serverActionsManifest.encryptionKey\n\n  if (rawKey === undefined) {\n    throw new InvariantError('Missing encryption key for Server Actions')\n  }\n\n  __next_loaded_action_key = await crypto.subtle.importKey(\n    'raw',\n    stringToUint8Array(atob(rawKey)),\n    'AES-GCM',\n    true,\n    ['encrypt', 'decrypt']\n  )\n\n  return __next_loaded_action_key\n}\n\nfunction mergeClientReferenceManifests(\n  clientReferenceManifestsPerPage: DeepReadonly<\n    Record<string, ClientReferenceManifest>\n  >\n): ClientReferenceManifestForRsc {\n  const clientReferenceManifests = Object.values(\n    clientReferenceManifestsPerPage as Record<string, ClientReferenceManifest>\n  )\n\n  const mergedClientReferenceManifest: ClientReferenceManifestForRsc = {\n    clientModules: {},\n    edgeRscModuleMapping: {},\n    rscModuleMapping: {},\n  }\n\n  for (const clientReferenceManifest of clientReferenceManifests) {\n    mergedClientReferenceManifest.clientModules = {\n      ...mergedClientReferenceManifest.clientModules,\n      ...clientReferenceManifest.clientModules,\n    }\n    mergedClientReferenceManifest.edgeRscModuleMapping = {\n      ...mergedClientReferenceManifest.edgeRscModuleMapping,\n      ...clientReferenceManifest.edgeRscModuleMapping,\n    }\n    mergedClientReferenceManifest.rscModuleMapping = {\n      ...mergedClientReferenceManifest.rscModuleMapping,\n      ...clientReferenceManifest.rscModuleMapping,\n    }\n  }\n\n  return mergedClientReferenceManifest\n}\n","/* eslint-disable import/no-extraneous-dependencies */\nimport 'server-only'\n\n/* eslint-disable import/no-extraneous-dependencies */\nimport { renderToReadableStream } from 'react-server-dom-webpack/server'\n/* eslint-disable import/no-extraneous-dependencies */\nimport { createFromReadableStream } from 'react-server-dom-webpack/client'\n\nimport { streamToString } from '../stream-utils/node-web-streams-helper'\nimport {\n  arrayBufferToString,\n  decrypt,\n  encrypt,\n  getActionEncryptionKey,\n  getClientReferenceManifestForRsc,\n  getServerModuleMap,\n  stringToUint8Array,\n} from './encryption-utils'\nimport {\n  getCacheSignal,\n  getPrerenderResumeDataCache,\n  getRenderResumeDataCache,\n  workUnitAsyncStorage,\n} from './work-unit-async-storage.external'\nimport { createHangingInputAbortSignal } from './dynamic-rendering'\nimport React from 'react'\n\nconst isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nconst filterStackFrame =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../lib/source-maps') as typeof import('../lib/source-maps'))\n        .filterStackFrameDEV\n    : undefined\nconst findSourceMapURL =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../lib/source-maps') as typeof import('../lib/source-maps'))\n        .findSourceMapURLDEV\n    : undefined\n\n/**\n * Decrypt the serialized string with the action id as the salt.\n */\nasync function decodeActionBoundArg(actionId: string, arg: string) {\n  const key = await getActionEncryptionKey()\n  if (typeof key === 'undefined') {\n    throw new Error(\n      `Missing encryption key for Server Action. This is a bug in Next.js`\n    )\n  }\n\n  // Get the iv (16 bytes) and the payload from the arg.\n  const originalPayload = atob(arg)\n  const ivValue = originalPayload.slice(0, 16)\n  const payload = originalPayload.slice(16)\n\n  const decrypted = textDecoder.decode(\n    await decrypt(key, stringToUint8Array(ivValue), stringToUint8Array(payload))\n  )\n\n  if (!decrypted.startsWith(actionId)) {\n    throw new Error('Invalid Server Action payload: failed to decrypt.')\n  }\n\n  return decrypted.slice(actionId.length)\n}\n\n/**\n * Encrypt the serialized string with the action id as the salt. Add a prefix to\n * later ensure that the payload is correctly decrypted, similar to a checksum.\n */\nasync function encodeActionBoundArg(actionId: string, arg: string) {\n  const key = await getActionEncryptionKey()\n  if (key === undefined) {\n    throw new Error(\n      `Missing encryption key for Server Action. This is a bug in Next.js`\n    )\n  }\n\n  // Get 16 random bytes as iv.\n  const randomBytes = new Uint8Array(16)\n  workUnitAsyncStorage.exit(() => crypto.getRandomValues(randomBytes))\n  const ivValue = arrayBufferToString(randomBytes.buffer)\n\n  const encrypted = await encrypt(\n    key,\n    randomBytes,\n    textEncoder.encode(actionId + arg)\n  )\n\n  return btoa(ivValue + arrayBufferToString(encrypted))\n}\n\nenum ReadStatus {\n  Ready,\n  Pending,\n  Complete,\n}\n\n// Encrypts the action's bound args into a string. For the same combination of\n// actionId and args the same cached promise is returned. This ensures reference\n// equality for returned objects from \"use cache\" functions when they're invoked\n// multiple times within one render pass using the same bound args.\nexport const encryptActionBoundArgs = React.cache(\n  async function encryptActionBoundArgs(actionId: string, ...args: any[]) {\n    const workUnitStore = workUnitAsyncStorage.getStore()\n    const cacheSignal = workUnitStore\n      ? getCacheSignal(workUnitStore)\n      : undefined\n\n    const { clientModules } = getClientReferenceManifestForRsc()\n\n    // Create an error before any asynchronous calls, to capture the original\n    // call stack in case we need it when the serialization errors.\n    const error = new Error()\n    Error.captureStackTrace(error, encryptActionBoundArgs)\n\n    let didCatchError = false\n\n    const hangingInputAbortSignal = workUnitStore\n      ? createHangingInputAbortSignal(workUnitStore)\n      : undefined\n\n    let readStatus = ReadStatus.Ready\n    function startReadOnce() {\n      if (readStatus === ReadStatus.Ready) {\n        readStatus = ReadStatus.Pending\n        cacheSignal?.beginRead()\n      }\n    }\n\n    function endReadIfStarted() {\n      if (readStatus === ReadStatus.Pending) {\n        cacheSignal?.endRead()\n      }\n      readStatus = ReadStatus.Complete\n    }\n\n    // streamToString might take longer than a microtask to resolve and then other things\n    // waiting on the cache signal might not realize there is another cache to fill so if\n    // we are no longer waiting on the bound args serialization via the hangingInputAbortSignal\n    // we should eagerly start the cache read to prevent other readers of the cache signal from\n    // missing this cache fill. We use a idempotent function to only start reading once because\n    // it's also possible that streamToString finishes before the hangingInputAbortSignal aborts.\n    if (hangingInputAbortSignal && cacheSignal) {\n      hangingInputAbortSignal.addEventListener('abort', startReadOnce, {\n        once: true,\n      })\n    }\n\n    // Using Flight to serialize the args into a string.\n    const serialized = await streamToString(\n      renderToReadableStream(args, clientModules, {\n        filterStackFrame,\n        signal: hangingInputAbortSignal,\n        onError(err) {\n          if (hangingInputAbortSignal?.aborted) {\n            return\n          }\n\n          // We're only reporting one error at a time, starting with the first.\n          if (didCatchError) {\n            return\n          }\n\n          didCatchError = true\n\n          // Use the original error message together with the previously created\n          // stack, because err.stack is a useless Flight Server call stack.\n          error.message = err instanceof Error ? err.message : String(err)\n        },\n      }),\n      // We pass the abort signal to `streamToString` so that no chunks are\n      // included that are emitted after the signal was already aborted. This\n      // ensures that we can encode hanging promises.\n      hangingInputAbortSignal\n    )\n\n    if (didCatchError) {\n      if (process.env.NODE_ENV === 'development') {\n        // Logging the error is needed for server functions that are passed to the\n        // client where the decryption is not done during rendering. Console\n        // replaying allows us to still show the error dev overlay in this case.\n        console.error(error)\n      }\n\n      endReadIfStarted()\n      throw error\n    }\n\n    if (!workUnitStore) {\n      // We don't need to call cacheSignal.endRead here because we can't have a cacheSignal\n      // if we do not have a workUnitStore.\n      return encodeActionBoundArg(actionId, serialized)\n    }\n\n    startReadOnce()\n\n    const prerenderResumeDataCache = getPrerenderResumeDataCache(workUnitStore)\n    const renderResumeDataCache = getRenderResumeDataCache(workUnitStore)\n    const cacheKey = actionId + serialized\n\n    const cachedEncrypted =\n      prerenderResumeDataCache?.encryptedBoundArgs.get(cacheKey) ??\n      renderResumeDataCache?.encryptedBoundArgs.get(cacheKey)\n\n    if (cachedEncrypted) {\n      return cachedEncrypted\n    }\n\n    const encrypted = await encodeActionBoundArg(actionId, serialized)\n\n    endReadIfStarted()\n    prerenderResumeDataCache?.encryptedBoundArgs.set(cacheKey, encrypted)\n\n    return encrypted\n  }\n)\n\n// Decrypts the action's bound args from the encrypted string.\nexport async function decryptActionBoundArgs(\n  actionId: string,\n  encryptedPromise: Promise<string>\n) {\n  const encrypted = await encryptedPromise\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  let decrypted: string | undefined\n\n  if (workUnitStore) {\n    const cacheSignal = getCacheSignal(workUnitStore)\n    const prerenderResumeDataCache = getPrerenderResumeDataCache(workUnitStore)\n    const renderResumeDataCache = getRenderResumeDataCache(workUnitStore)\n\n    decrypted =\n      prerenderResumeDataCache?.decryptedBoundArgs.get(encrypted) ??\n      renderResumeDataCache?.decryptedBoundArgs.get(encrypted)\n\n    if (!decrypted) {\n      cacheSignal?.beginRead()\n      decrypted = await decodeActionBoundArg(actionId, encrypted)\n      cacheSignal?.endRead()\n      prerenderResumeDataCache?.decryptedBoundArgs.set(encrypted, decrypted)\n    }\n  } else {\n    decrypted = await decodeActionBoundArg(actionId, encrypted)\n  }\n\n  const { edgeRscModuleMapping, rscModuleMapping } =\n    getClientReferenceManifestForRsc()\n\n  // Using Flight to deserialize the args from the string.\n  const deserialized = await createFromReadableStream(\n    new ReadableStream({\n      start(controller) {\n        controller.enqueue(textEncoder.encode(decrypted))\n\n        switch (workUnitStore?.type) {\n          case 'prerender':\n          case 'prerender-runtime':\n            // Explicitly don't close the stream here (until prerendering is\n            // complete) so that hanging promises are not rejected.\n            if (workUnitStore.renderSignal.aborted) {\n              controller.close()\n            } else {\n              workUnitStore.renderSignal.addEventListener(\n                'abort',\n                () => controller.close(),\n                { once: true }\n              )\n            }\n            break\n          case 'prerender-client':\n          case 'prerender-ppr':\n          case 'prerender-legacy':\n          case 'request':\n          case 'cache':\n          case 'private-cache':\n          case 'unstable-cache':\n          case undefined:\n            return controller.close()\n          default:\n            workUnitStore satisfies never\n        }\n      },\n    }),\n    {\n      findSourceMapURL,\n      serverConsumerManifest: {\n        // moduleLoading must be null because we don't want to trigger preloads of ClientReferences\n        // to be added to the current execution. Instead, we'll wait for any ClientReference\n        // to be emitted which themselves will handle the preloading.\n        moduleLoading: null,\n        moduleMap: isEdgeRuntime ? edgeRscModuleMapping : rscModuleMapping,\n        serverModuleMap: getServerModuleMap(),\n      },\n    }\n  )\n\n  return deserialized\n}\n","'use server';\n\nimport { headers } from 'next/headers';\n\ninterface MetadataHeaders {\n  nodeVersion?: string;\n  nextVersion?: string;\n  npmConfigUserAgent?: string;\n  userAgent: string;\n  port?: string;\n  host: string;\n  xHost: string;\n  xPort: string;\n  xProtocol: string;\n  xClerkAuthStatus: string;\n}\n\n/**\n * Collects metadata from the environment and request headers\n */\nexport async function collectKeylessMetadata(): Promise<MetadataHeaders> {\n  const headerStore = await headers(); // eslint-disable-line\n\n  return {\n    nodeVersion: process.version,\n    nextVersion: getNextVersion(),\n    npmConfigUserAgent: process.env.npm_config_user_agent, // eslint-disable-line\n    userAgent: headerStore.get('User-Agent') ?? 'unknown user-agent',\n    port: process.env.PORT, // eslint-disable-line\n    host: headerStore.get('host') ?? 'unknown host',\n    xPort: headerStore.get('x-forwarded-port') ?? 'unknown x-forwarded-port',\n    xHost: headerStore.get('x-forwarded-host') ?? 'unknown x-forwarded-host',\n    xProtocol: headerStore.get('x-forwarded-proto') ?? 'unknown x-forwarded-proto',\n    xClerkAuthStatus: headerStore.get('x-clerk-auth-status') ?? 'unknown x-clerk-auth-status',\n  };\n}\n\n/**\n * Extracts Next.js version from process title\n */\nfunction getNextVersion(): string | undefined {\n  try {\n    return process.title ?? 'unknown-process-title'; // 'next-server (v15.4.5)'\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * Converts metadata to HTTP headers\n */\nexport function formatMetadataHeaders(metadata: MetadataHeaders): Headers {\n  const headers = new Headers();\n\n  if (metadata.nodeVersion) {\n    headers.set('Clerk-Node-Version', metadata.nodeVersion);\n  }\n\n  if (metadata.nextVersion) {\n    headers.set('Clerk-Next-Version', metadata.nextVersion);\n  }\n\n  if (metadata.npmConfigUserAgent) {\n    headers.set('Clerk-NPM-Config-User-Agent', metadata.npmConfigUserAgent);\n  }\n\n  if (metadata.userAgent) {\n    headers.set('Clerk-Client-User-Agent', metadata.userAgent);\n  }\n\n  if (metadata.port) {\n    headers.set('Clerk-Node-Port', metadata.port);\n  }\n\n  if (metadata.host) {\n    headers.set('Clerk-Client-Host', metadata.host);\n  }\n\n  if (metadata.xPort) {\n    headers.set('Clerk-X-Port', metadata.xPort);\n  }\n\n  if (metadata.xHost) {\n    headers.set('Clerk-X-Host', metadata.xHost);\n  }\n\n  if (metadata.xProtocol) {\n    headers.set('Clerk-X-Protocol', metadata.xProtocol);\n  }\n\n  if (metadata.xClerkAuthStatus) {\n    headers.set('Clerk-Auth-Status', metadata.xClerkAuthStatus);\n  }\n\n  return headers;\n}\n","import \"../chunk-BUSYA2B4.js\";\nimport { canUseKeyless } from \"../utils/feature-flags\";\nconst keylessCookiePrefix = `__clerk_keys_`;\nasync function hashString(str) {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(str);\n  const hashBuffer = await crypto.subtle.digest(\"SHA-256\", data);\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\n  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return hashHex.slice(0, 16);\n}\nasync function getKeylessCookieName() {\n  const PATH = process.env.PWD;\n  if (!PATH) {\n    return `${keylessCookiePrefix}${0}`;\n  }\n  const lastThreeDirs = PATH.split(\"/\").filter(Boolean).slice(-3).reverse().join(\"/\");\n  const hash = await hashString(lastThreeDirs);\n  return `${keylessCookiePrefix}${hash}`;\n}\nasync function getKeylessCookieValue(getter) {\n  if (!canUseKeyless) {\n    return void 0;\n  }\n  const keylessCookieName = await getKeylessCookieName();\n  let keyless;\n  try {\n    if (keylessCookieName) {\n      keyless = JSON.parse(getter(keylessCookieName) || \"{}\");\n    }\n  } catch {\n    keyless = void 0;\n  }\n  return keyless;\n}\nexport {\n  getKeylessCookieName,\n  getKeylessCookieValue\n};\n//# sourceMappingURL=keyless.js.map","\"use server\";\nimport { cookies, headers } from \"next/headers\";\nimport { redirect, RedirectType } from \"next/navigation\";\nimport { errorThrower } from \"../server/errorThrower\";\nimport { detectClerkMiddleware } from \"../server/headers-utils\";\nimport { getKeylessCookieName, getKeylessCookieValue } from \"../server/keyless\";\nimport { canUseKeyless } from \"../utils/feature-flags\";\nconst keylessCookieConfig = {\n  secure: false,\n  httpOnly: false,\n  sameSite: \"lax\"\n};\nasync function syncKeylessConfigAction(args) {\n  const { claimUrl, publishableKey, secretKey, returnUrl } = args;\n  const cookieStore = await cookies();\n  const request = new Request(\"https://placeholder.com\", { headers: await headers() });\n  const keyless = await getKeylessCookieValue((name) => {\n    var _a;\n    return (_a = cookieStore.get(name)) == null ? void 0 : _a.value;\n  });\n  const pksMatch = (keyless == null ? void 0 : keyless.publishableKey) === publishableKey;\n  const sksMatch = (keyless == null ? void 0 : keyless.secretKey) === secretKey;\n  if (pksMatch && sksMatch) {\n    return;\n  }\n  cookieStore.set(\n    await getKeylessCookieName(),\n    JSON.stringify({ claimUrl, publishableKey, secretKey }),\n    keylessCookieConfig\n  );\n  if (detectClerkMiddleware(request)) {\n    redirect(`/clerk-sync-keyless?returnUrl=${returnUrl}`, RedirectType.replace);\n    return;\n  }\n  return;\n}\nasync function createOrReadKeylessAction() {\n  if (!canUseKeyless) {\n    return null;\n  }\n  const result = await import(\"../server/keyless-node.js\").then((m) => m.createOrReadKeyless()).catch(() => null);\n  if (!result) {\n    errorThrower.throwMissingPublishableKeyError();\n    return null;\n  }\n  const { clerkDevelopmentCache, createKeylessModeMessage } = await import(\"../server/keyless-log-cache.js\");\n  clerkDevelopmentCache == null ? void 0 : clerkDevelopmentCache.log({\n    cacheKey: result.publishableKey,\n    msg: createKeylessModeMessage(result)\n  });\n  const { claimUrl, publishableKey, secretKey, apiKeysUrl } = result;\n  void (await cookies()).set(\n    await getKeylessCookieName(),\n    JSON.stringify({ claimUrl, publishableKey, secretKey }),\n    keylessCookieConfig\n  );\n  return {\n    claimUrl,\n    publishableKey,\n    apiKeysUrl\n  };\n}\nasync function deleteKeylessAction() {\n  if (!canUseKeyless) {\n    return;\n  }\n  await import(\"../server/keyless-node.js\").then((m) => m.removeKeyless()).catch(() => {\n  });\n  return;\n}\nasync function detectKeylessEnvDriftAction() {\n  if (!canUseKeyless) {\n    return;\n  }\n  try {\n    const { detectKeylessEnvDrift } = await import(\"../server/keyless-telemetry.js\");\n    await detectKeylessEnvDrift();\n  } catch {\n  }\n}\nexport {\n  createOrReadKeylessAction,\n  deleteKeylessAction,\n  detectKeylessEnvDriftAction,\n  syncKeylessConfigAction\n};\n"],"names":["arrayBufferToString","decrypt","encrypt","getActionEncryptionKey","getClientReferenceManifestForRsc","getServerModuleMap","setReferenceManifestsSingleton","stringToUint8Array","__next_loaded_action_key","buffer","bytes","Uint8Array","len","byteLength","String","fromCharCode","apply","binary","i","length","arr","charCodeAt","key","iv","data","crypto","subtle","name","SERVER_ACTION_MANIFESTS_SINGLETON","Symbol","for","page","clientReferenceManifest","serverActionsManifest","serverModuleMap","globalThis","clientReferenceManifestsPerPage","normalizeAppPath","serverActionsManifestSingleton","InvariantError","workStore","workAsyncStorage","getStore","mergeClientReferenceManifests","route","rawKey","process","env","NEXT_SERVER_ACTIONS_ENCRYPTION_KEY","encryptionKey","undefined","importKey","atob","clientReferenceManifests","Object","values","mergedClientReferenceManifest","clientModules","edgeRscModuleMapping","rscModuleMapping","decryptActionBoundArgs","encryptActionBoundArgs","isEdgeRuntime","NEXT_RUNTIME","textEncoder","TextEncoder","textDecoder","TextDecoder","filterStackFrame","NODE_ENV","require","filterStackFrameDEV","findSourceMapURL","findSourceMapURLDEV","decodeActionBoundArg","actionId","arg","Error","originalPayload","ivValue","slice","payload","decrypted","decode","startsWith","encodeActionBoundArg","randomBytes","workUnitAsyncStorage","exit","getRandomValues","encrypted","encode","btoa","ReadStatus","React","cache","args","workUnitStore","cacheSignal","getCacheSignal","error","captureStackTrace","didCatchError","hangingInputAbortSignal","createHangingInputAbortSignal","readStatus","startReadOnce","beginRead","endReadIfStarted","endRead","addEventListener","once","serialized","streamToString","renderToReadableStream","signal","onError","err","aborted","message","console","prerenderResumeDataCache","getPrerenderResumeDataCache","renderResumeDataCache","getRenderResumeDataCache","cacheKey","cachedEncrypted","encryptedBoundArgs","get","set","encryptedPromise","decryptedBoundArgs","deserialized","createFromReadableStream","ReadableStream","start","controller","enqueue","type","renderSignal","close","serverConsumerManifest","moduleLoading","moduleMap","headers"],"mappings":"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","ignoreList":[0,1,3,4]}